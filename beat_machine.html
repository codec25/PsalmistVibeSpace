<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PSALMIST // Beat Machine</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root { 
            --bg: #020406; --panel: rgba(15, 20, 30, 0.95); --blue: #4facfe; 
            --gold: #ffcc00; --red: #ff4b2b; --border: rgba(79, 172, 254, 0.2); --green: #00ff88; 
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body { 
            margin: 0; background: var(--bg); color: #fff; font-family: 'Orbitron', sans-serif; 
            display: flex; flex-direction: column; align-items: center; min-height: 100vh;
            padding: env(safe-area-inset-top) 10px 40px 10px;
            overflow-x: hidden;
        }

        header { width: 100%; max-width: 1100px; padding: 20px 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border); margin-bottom: 20px; }
        .logo { font-weight: 900; letter-spacing: 2px; font-size: 0.9rem; }
        .logo span { color: var(--green); }

        .studio-nav { display: flex; gap: 10px; align-items: center; }
        .btn-action-nav {
            background: #0a0e17; border: 1px solid var(--border); color: var(--blue); 
            padding: 8px 12px; font-family: 'Orbitron'; font-size: 0.55rem; border-radius: 6px;
            cursor: pointer; text-decoration: none; transition: 0.2s;
        }
        .btn-green { background: var(--green); color: #000; font-weight: 900; border: none; }

        .viz-terminal {
            width: 100%; max-width: 1100px; height: 100px; background: #000;
            border: 1px solid var(--border); border-radius: 12px; margin-bottom: 20px;
            overflow: hidden; position: relative;
        }
        canvas { width: 100%; height: 100%; }

        .controls-grid {
            width: 100%; max-width: 1100px; display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px; margin-bottom: 20px;
        }

        .ctrl-box { background: var(--panel); padding: 15px; border-radius: 12px; border: 1px solid var(--border); }
        .ctrl-box label { display: block; font-size: 0.5rem; color: #555; margin-bottom: 8px; letter-spacing: 1px; }

        .btn-main {
            background: var(--blue); color: #000; border: none; padding: 15px;
            font-family: 'Orbitron'; font-weight: 900; border-radius: 50px; cursor: pointer; width: 100%;
            font-size: 0.6rem; transition: 0.2s;
        }
        .btn-main:active { transform: scale(0.98); }
        #play-btn.active { background: var(--green); }
        .btn-red { background: var(--red); color: white; }

        .sequencer-container { 
            width: 100%; max-width: 1100px; background: var(--panel); 
            border: 1px solid var(--border); border-radius: 12px; padding: 20px;
            overflow-x: auto;
        }

        .track-row { display: grid; grid-template-columns: 150px 1fr; gap: 20px; align-items: center; margin-bottom: 12px; min-width: 1400px; }
        .track-name { font-size: 0.65rem; font-weight: 700; color: var(--green); cursor:pointer; }
        .load-btn { font-size: 0.45rem; color: var(--gold); border: 1px solid var(--gold); padding: 2px 5px; border-radius: 3px; cursor: pointer; }

        .step-grid { display: grid; grid-template-columns: repeat(32, 1fr); gap: 6px; }
        .step { 
            aspect-ratio: 1/1; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05);
            border-radius: 4px; cursor: pointer; min-height: 35px; transition: 0.1s;
        }
        .step.active { background: var(--green); box-shadow: 0 0 10px var(--green); border: none; }
        .step.playing { border: 2px solid var(--gold); }

        #mission-briefing {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 2000; display: flex; align-items: center; justify-content: center; padding: 20px;
        }
        .brief-card {
            max-width: 500px; background: var(--panel); border: 1px solid var(--green);
            padding: 30px; border-radius: 16px; text-align: center;
        }
    </style>
</head>
<body>

    <div id="mission-briefing">
        <div class="brief-card">
            <h2 style="color: var(--green); font-size: 1rem; letter-spacing: 2px;">PSALMIST // BEAT_MACHINE</h2>
            <p style="font-size: 0.75rem; text-align: left; color: #ccc; line-height: 1.6; margin: 20px 0;">
                • Program the 32-step grid to trigger rhythmic pulses.<br>
                • [SPACE] to Toggle Play/Stop.<br>
                • [C] to Clear Grid.<br>
                • Click a Track Name to cycle preset patterns.
            </p>
            <button class="btn-main" style="background: var(--green);" onclick="closeBriefing()">INITIALIZE_DRUMS</button>
        </div>
    </div>

    <header>
        <div class="logo">PSALMIST // <span>BEAT_MACHINE</span></div>
        <div class="studio-nav">
            <a href="rhythm_hub.html" class="btn-action-nav">BACK_TO_RHYTHM</a>
            <button class="btn-action-nav btn-green" onclick="togglePlay()" id="play-btn-nav">PLAY</button>
        </div>
    </header>

    <div class="viz-terminal"><canvas id="visualizer"></canvas></div>

    <div class="controls-grid">
        <div class="ctrl-box">
            <label>TEMPO & SESSION</label>
            <input type="range" id="bpm-slider" min="60" max="200" value="120" oninput="updateTempo(this.value)" style="width:100%;">
            <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                <div id="bpm-val" style="font-size:0.7rem; color:var(--gold);">120 BPM</div>
                <div id="session-timer" style="font-size:0.55rem; color:var(--blue); opacity:0.5;">00:00</div>
            </div>
        </div>
        <div class="ctrl-box">
            <label>ENGINE_STATUS</label>
            <button class="btn-main" id="play-btn" onclick="togglePlay()">START_ENGINE</button>
        </div>
        <div class="ctrl-box">
            <label>CONSTRUCTION</label>
            <button class="btn-main btn-red" onclick="clearGrid()">CLEAR_GRID [C]</button>
        </div>
        <div class="ctrl-box">
            <label>RECORDING</label>
            <button class="btn-main" onclick="toggleRecording()" id="rec-btn">REC_BEAT</button>
            <a id="download-link" style="display:none;margin-top:8px;font-size:0.55rem;color:var(--gold);text-align:center;" download="beat_machine_export.wav">DOWNLOAD_WAV</a>
        </div>
    </div>

    <div class="sequencer-container">
        <div style="text-align: center; font-size: 0.45rem; color: var(--green); margin-bottom: 15px; letter-spacing: 2px; opacity: 0.6;">RHYTHMIC_CONSTRUCTION_ZONE</div>
        <div id="sequencer-grid"></div>
    </div>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const analyzer = audioCtx.createAnalyser();
        const dest = audioCtx.createMediaStreamDestination();
        
        const trackNames = ["KICK", "SNARE", "HI_HAT", "CONGA", "OPEN_HAT"];
        let sampleBuffers = [null, null, null, null, null];
        let grid = Array(5).fill().map(() => Array(32).fill(false));
        let isPlaying = false, currentStep = 0, nextNoteTime = 0, tempo = 120;
        let sessionSeconds = 0;
        let mediaRecorder = null;
        let recordedChunks = [];

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
            if (e.key.toLowerCase() === 'c') { clearGrid(); }
        });

        const patternPresets = {
            KICK: [
                [1,0,0,0, 0,0,1,0, 1,0,0,0, 0,0,1,0, 1,0,0,0, 0,0,1,0, 1,0,0,0, 0,0,1,0],
                [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,1,0,0, 1,0,0,1, 0,0,1,0, 1,0,0,1, 0,1,0,0]
            ],
            SNARE: [
                [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
                [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0]
            ],
            HI_HAT: [
                Array(32).fill(1),
                [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0]
            ],
            CONGA: [
                [0,0,1,0, 0,1,0,0, 0,0,1,1, 0,0,0,0, 0,0,1,0, 0,1,0,0, 0,0,1,1, 0,0,0,0]
            ],
            OPEN_HAT: [
                [0,0,0,0, 0,0,0,1, 0,0,0,0, 0,0,0,1, 0,0,0,0, 0,0,0,1, 0,0,0,0, 0,0,0,1]
            ]
        };
        let patternIndex = [0,0,0,0,0];

        function init() {
            const seq = document.getElementById('sequencer-grid');
            seq.innerHTML = '';
            trackNames.forEach((name, i) => {
                const row = document.createElement('div');
                row.className = 'track-row';
                row.innerHTML = `
                    <div class="track-info">
                        <div class="track-header">
                            <span class="track-name" id="n-${i}" onclick="cyclePattern(${i})">${name}</span>
                            <label class="load-btn" for="s-${i}">LOAD</label>
                        </div>
                        <input type="file" id="s-${i}" style="display:none" accept="audio/*" onchange="loadSample(${i}, this)">
                        <input type="range" min="0" max="1" step="0.01" value="0.7" id="v-${i}" style="width:100%;">
                    </div>
                    <div class="step-grid" id="g-${i}"></div>
                `;
                const g = row.querySelector(`#g-${i}`);
                for(let s=0; s<32; s++) {
                    const b = document.createElement('div');
                    b.className = 'step';
                    b.onclick = () => { 
                        if(audioCtx.state==='suspended') audioCtx.resume(); 
                        grid[i][s]=!grid[i][s]; 
                        b.classList.toggle('active'); 
                    };
                    g.appendChild(b);
                }
                seq.appendChild(row);
            });
            loadDefaultDrums();
            drawVisualizer();
            setInterval(updateSession, 1000);
        }

        async function loadSample(idx, input) {
            const file = input.files[0];
            if(!file) return;
            const buffer = await audioCtx.decodeAudioData(await file.arrayBuffer());
            sampleBuffers[idx] = buffer;
            document.getElementById(`n-${idx}`).style.color = "var(--blue)";
        }

        /* ===== PROFESSIONAL DRUM SYNTHS ===== */

        function createKick() {
            const len = audioCtx.sampleRate * 0.6;
            const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            let phase = 0;
            for(let i=0;i<len;i++){
                const t = i / audioCtx.sampleRate;
                const freq = 140 * Math.exp(-t * 18);
                phase += 2 * Math.PI * freq / audioCtx.sampleRate;
                const env = Math.exp(-t * 10);
                d[i] = Math.sin(phase) * env;
            }
            return buf;
        }

        function createSnare() {
            const len = audioCtx.sampleRate * 0.25;
            const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            for(let i=0;i<len;i++){
                const t = i / audioCtx.sampleRate;
                const noise = (Math.random()*2-1) * Math.exp(-t * 18);
                const tone = Math.sin(2*Math.PI*180*t) * Math.exp(-t*25);
                d[i] = noise * 0.8 + tone * 0.3;
            }
            return buf;
        }

        function createClosedHat() {
            const len = audioCtx.sampleRate * 0.06;
            const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            for(let i=0;i<len;i++){
                const t = i / audioCtx.sampleRate;
                d[i] = (Math.random()*2-1) * Math.exp(-t * 80);
            }
            return buf;
        }

        function createOpenHat() {
            const len = audioCtx.sampleRate * 0.35;
            const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            for(let i=0;i<len;i++){
                const t = i / audioCtx.sampleRate;
                d[i] = (Math.random()*2-1) * Math.exp(-t * 12);
            }
            return buf;
        }

        function createConga() {
            const len = audioCtx.sampleRate * 0.4;
            const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            let phase = 0;
            for(let i=0;i<len;i++){
                const t = i / audioCtx.sampleRate;
                const freq = 420 * Math.exp(-t * 6);
                phase += 2 * Math.PI * freq / audioCtx.sampleRate;
                const env = Math.exp(-t * 8);
                d[i] = Math.sin(phase) * env;
            }
            return buf;
        }

        function loadDefaultDrums() {
            sampleBuffers[0] = createKick();
            sampleBuffers[1] = createSnare();
            sampleBuffers[2] = createClosedHat();
            sampleBuffers[3] = createConga();
            sampleBuffers[4] = createOpenHat();
        }

        function triggerSound(idx, time) {
            if(!sampleBuffers[idx]) return;
            const vol = parseFloat(document.getElementById(`v-${idx}`).value);
            const s = audioCtx.createBufferSource();
            s.buffer = sampleBuffers[idx];
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(vol, time);
            s.connect(g).connect(audioCtx.destination);
            s.connect(g).connect(analyzer);
            s.connect(g).connect(dest);
            s.start(time);
        }

        function scheduler() {
            while (nextNoteTime < audioCtx.currentTime + 0.1) {
                for(let i=0; i<5; i++) { 
                    if(grid[i][currentStep]) triggerSound(i, nextNoteTime); 
                }
                updateVisual(currentStep);
                nextNoteTime += (60 / tempo / 8);
                currentStep = (currentStep + 1) % 32;
            }
            if (isPlaying) setTimeout(scheduler, 25);
        }

        function updateVisual(s) {
            document.querySelectorAll('.step').forEach(el => el.classList.remove('playing'));
            document.querySelectorAll('.track-row').forEach(row => {
                const step = row.querySelector(`.step:nth-child(${s+1})`);
                if(step) step.classList.add('playing');
            });
        }

        function togglePlay() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = !isPlaying;
            document.getElementById('play-btn').innerText = isPlaying ? "STOP_ENGINE" : "START_ENGINE";
            document.getElementById('play-btn').classList.toggle('active', isPlaying);
            document.getElementById('play-btn-nav').innerText = isPlaying ? "STOP" : "PLAY";
            if (isPlaying) { currentStep = 0; nextNoteTime = audioCtx.currentTime; scheduler(); }
        }

        function clearGrid() {
            grid = Array(5).fill().map(() => Array(32).fill(false));
            document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
        }

        function updateTempo(v) { tempo = v; document.getElementById('bpm-val').innerText = v + " BPM"; }
        function closeBriefing() { document.getElementById('mission-briefing').style.display='none'; }
        
        function cyclePattern(track) {
            const name = trackNames[track];
            if(!patternPresets[name]) return;
            patternIndex[track] = (patternIndex[track] + 1) % patternPresets[name].length;
            grid[track] = patternPresets[name][patternIndex[track]].map(v => !!v);
            const steps = document.querySelectorAll(`#g-${track} .step`);
            steps.forEach((s,i)=>s.classList.toggle('active',grid[track][i]));
        }

        function updateSession() {
            sessionSeconds++;
            const mins = Math.floor(sessionSeconds/60).toString().padStart(2,'0');
            const secs = (sessionSeconds%60).toString().padStart(2,'0');
            document.getElementById('session-timer').innerText = `${mins}:${secs}`;
        }

        function toggleRecording() {
            if (!mediaRecorder || mediaRecorder.state === "inactive") {
                recordedChunks = [];
                mediaRecorder = new MediaRecorder(dest.stream);
                mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: "audio/wav" });
                    const url = URL.createObjectURL(blob);
                    const link = document.getElementById("download-link");
                    link.href = url; link.style.display = "block";
                };
                mediaRecorder.start();
                document.getElementById("rec-btn").innerText = "STOP_REC";
                document.getElementById("rec-btn").style.background = "var(--red)";
            } else {
                mediaRecorder.stop();
                document.getElementById("rec-btn").innerText = "REC_BEAT";
                document.getElementById("rec-btn").style.background = "var(--blue)";
            }
        }

        function drawVisualizer() {
            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');
            function render() {
                requestAnimationFrame(render);
                const data = new Uint8Array(analyzer.frequencyBinCount);
                analyzer.getByteTimeDomainData(data);
                ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.strokeStyle = isPlaying ? '#00ff88' : '#4facfe'; ctx.lineWidth = 2; ctx.beginPath();
                let slice = canvas.width / data.length; let x = 0;
                for(let i=0; i<data.length; i++) {
                    let v = data[i]/128.0; let y = v * (canvas.height/2);
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                    x += slice;
                }
                ctx.stroke();
            }
            render();
        }

        window.onload = () => {
            const c = document.getElementById('visualizer');
            c.width = c.offsetWidth; c.height = c.offsetHeight;
            init();
        };
    </script>
</body>
</html>
